% Created 2016-06-18 Sa 23:26
\documentclass{beamer}
%\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{fontspec}
\setmonofont{Source Code Pro}

\usepackage{minted}
\setminted{fontsize=\fontsize{5pt}{6pt},breaklines=true}
%workaround to remove red boxes
\AtBeginEnvironment{minted}{\renewcommand{\fcolorbox}[4][]{#4}}
\usemintedstyle{tango}

\usepackage{newunicodechar}
\newfontfamily{\freeserif}{DejaVu Sans}
\newunicodechar{‚Ñï}{\freeserif{‚Ñï}}
\newunicodechar{‚Çê}{\freeserif{‚Çê}}
\newunicodechar{‚ÇÅ}{\freeserif{‚ÇÅ}}
\newunicodechar{‚àà}{\freeserif{‚àà}}
\newunicodechar{ùìû}{\ensuremath{\mathcal{O}}}
\newunicodechar{‚àâ}{\freeserif{‚àâ}}
\newunicodechar{Œ†}{\freeserif{Œ†}}

\usetheme{default}
\author{Sebastian Ullrich}
\date{OPLSS 2016}
\title{Electrolysis}
\subtitle{Simple Verification of Rust Programs via Functional Purification\\[5mm]
\includegraphics[scale=1.4]{../logo}\\[-3mm]}
\institute[]{Karlsruhe Institute of Technology, advisor Gregor Snelting \\[1mm]
Carnegie Mellon University, advisor Jeremy Avigad}
\hypersetup{
 pdfauthor={Sebastian Ullrich},
 pdftitle={Electrolysis - Verifying Rust Programs via Functional Purification},
 pdflang={English}}
\begin{document}

\maketitle

%\begin{frame}{Outline}
%\tableofcontents
%\end{frame}

\section{Why Rust}

\begin{frame}{Why Rust? (What is Rust?)}
  Rust is a new systems programming language sponsored by Mozilla Research
  \begin{itemize}
    \item multi-paradigm with an ML-like syntax
    \item pursues ``the trifecta: safety, concurrency, and speed''
      \begin{itemize}
        \item \alert{speed} through zero-cost abstractions and manual memory management
        \item \alert{memory safety} through tracking reference lifetimes in the type system
        \item \alert{safe concurrency} through forbidding shared mutable references
      \end{itemize}
  \end{itemize}
  \uncover<2>{
    \begin{center}
      \includegraphics[height=3cm]{rustacean-orig-happy}
    \end{center}
  }
\end{frame}

\begin{frame}[fragile]{Why Rust: Because It's Almost Pure Already}
  \begin{itemize}
    \item turn destructive updates into functional ones
      \begin{columns}
        \column{0.25\textwidth}
        \color{gray}
        \begin{verbatim}
p.x += 1;
        \end{verbatim}
        \column{0.5\textwidth}
        \begin{verbatim}
let p = Point { x = p.x + 1, ..p };
        \end{verbatim}
      \end{columns}
    \item references: save value instead of pointer, write back at end of lifetime
      \begin{columns}
        \column{0.25\textwidth}
        \color{gray}
        \begin{verbatim}
let x = f(&mut p);
        \end{verbatim}
        \column{0.5\textwidth}
        \begin{verbatim}
let (x, p) = f(p);
        \end{verbatim}
      \end{columns}
  \end{itemize}
\end{frame}

\section{Simple Verification via Functional Purification}

\setbeamercovered{transparent}
\begin{frame}[t]{Simple Verification via Functional Purification}
  \begin{enumerate}
    \item \uncover<1>{make Rust program purely functional}
    \item transpile it into expression language of a theorem prover (Lean)
      \only<2>{
        \begin{itemize}
          \item run \texttt{rustc} up to CFG generation
          \item sort definitions topologically by dependencies
          \item extract loops from CFG and put them into loop combinator
          \item resolve static/dynamic trait calls
        \end{itemize}

        \hfill

        Things Rust fortunately does not have:
        \begin{itemize}
          \item exceptions
          \item subtyping
        \end{itemize}
      }
    \item \uncover<1>{prove correctness of the Lean definition}
  \end{enumerate}
\end{frame}

\section{Verifying \texttt{std::[T]::binary\_search}}

\begin{frame}[fragile]{Verifying \texttt{std::[T]::binary\_search}: Input}
  \begin{minted}{rust}
    fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>
        where F: FnMut(&'a T) -> Ordering
    {
        let mut base = 0usize;
        let mut s = self;

        loop {
            let (head, tail) = s.split_at(s.len() >> 1);
            if tail.is_empty() {
                return Err(base)
            }
            match f(&tail[0]) {
                Less => {
                    base += head.len() + 1;
                    s = &tail[1..];
                }
                Greater => s = head,
                Equal => return Ok(base + head.len()),
            }
        }
    }

    fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {
        self.binary_search_by(|p| p.cmp(x))
    }
  \end{minted}

  \begin{itemize}
    \item high-level implementation working with subslices instead of explicit indicing
    \item transitively uses
      \begin{itemize}
        \item[5] traits
        \item[6] structs and enums
        \item[7] functions
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Verifying \texttt{std::[T]::binary\_search}: Output}
  \begin{minted}{lean}
section
  parameters {F : Type‚ÇÅ} {T : Type‚ÇÅ}
  parameters [¬´ops.FnMut F (T)¬ª : ops.FnMut F (T) (cmp.Ordering)]
  parameters (self‚Çê : (slice T)) (f‚Çê : F)

  definition ¬´[T] as core.slice.SliceExt¬ª.binary_search_by.loop_4 (state__ : F √ó usize √ó (slice T)) : sem (sum (F √ó usize √ó (slice T)) ((result.Result usize usize))) :=
  ...

  definition ¬´[T] as core.slice.SliceExt¬ª.binary_search_by : sem ((result.Result usize usize)) :=
  let' self ‚Üê (self‚Çê);
  let' f ‚Üê (f‚Çê);
  let' base ‚Üê ((0 : nat));
  let' t1 ‚Üê (self);
  let' s ‚Üê (t1);
  loop (¬´[T] as core.slice.SliceExt¬ª.binary_search_by.loop_4) (f, base, s)
end

...

structure cmp.Ord [class] (Self : Type‚ÇÅ)  extends cmp.Eq Self, cmp.PartialOrd Self Self :=
(cmp : Self ‚Üí Self ‚Üí sem ((cmp.Ordering)))

definition ¬´[T] as core.slice.SliceExt¬ª.binary_search {T : Type‚ÇÅ} [¬´cmp.Ord T¬ª : cmp.Ord T] (self‚Çê : (slice T)) (x‚Çê : T) : sem ((result.Result usize usize)) :=
let' self ‚Üê (self‚Çê);
let' x ‚Üê (x‚Çê);
let' t0 ‚Üê (self);
let' t2 ‚Üê (x);
let' t1 ‚Üê ((Œª upvars‚Çê p‚Çê, let' p ‚Üê (p‚Çê);
let' t0 ‚Üê (p);
let' t1 ‚Üê ((upvars‚Çê));
dostep ¬´$tmp¬ª ‚Üê @cmp.Ord.cmp _ ¬´cmp.Ord T¬ª (t0) (t1);
let' ret ‚Üê ¬´$tmp¬ª;
return ret) (t2));
dostep ¬´$tmp¬ª ‚Üê @¬´[T] as core.slice.SliceExt¬ª.binary_search_by _ _ fn (t0) (t1);
let' ret ‚Üê ¬´$tmp¬ª;
return (ret)
  \end{minted}
\end{frame}

\begin{frame}[fragile]{Verifying \texttt{std::[T]::binary\_search}: Proof}
  \begin{minted}{lean}
/- fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord

Binary search a sorted slice for a given element.

If the value is found then Ok is returned, containing the index of the matching element;
if the value is not found then Err is returned, containing the index where a matching element could
be inserted while maintaining sorted order.-/
inductive binary_search_res : Result usize usize ‚Üí Prop :=
| found     : Œ†i, nth self i = some needle ‚Üí binary_search_res (Result.Ok i)
| not_found : Œ†i, needle ‚àâ self ‚Üí sorted le (insert_at self i needle) ‚Üí
  binary_search_res (Result.Err i)

...

theorem binary_search.spec :
  ‚àÉ‚ÇÄf ‚àà ùìû(Œªp, log‚ÇÇ p.1 * p.2) [at ‚àû √ó ‚àû],
  ‚àÄ(self : slice T) (needle : T), sorted le self ‚Üí sem.terminates_with_in
    (binary_search_res self needle)
    (f (length self, Ord'.cmp_max_cost needle self))
    (binary_search self needle) :=
...
  \end{minted} 
\end{frame}

\section{Conclusion and Future Work}

\begin{frame}{Conclusion and Future Work}
  \begin{itemize}
    \item a tool for verifying real-world Rust code
    \item correctness proof of a central stdlib algorithm

    \hfill

    \item next step: find a new algorithm to verify!
    \item possible enhancement: different monad stacks for e.g.\ complexity analysis, global side effects, \dots
    \item maybe allow some restricted forms of unsafe code
  \end{itemize}

  \hfill

  \begin{center}
    \large\url{github.com/Kha/electrolysis}
  \end{center}
\end{frame}

\end{document}
